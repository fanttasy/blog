<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>new.target</title>
      <link href="/blog//new-target/"/>
      <url>/blog//new-target/</url>
      
        <content type="html"><![CDATA[<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p><code>new.target</code>属性（ES6引入）允许你检测函数或构造方法是否通过<code>new</code>运算符进行调用。通过new运算符被初始化的函数或构造方法时，<code>new.target</code>返回一个指向构造方法或函数的引用，在普通的函数调用中，<code>new.target</code>返回<code>undefined</code></p></blockquote><p>  注意：</p><ul><li>在<code>arrow function</code>中，没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，<code>new.target</code>指向最近的外层函数的<code>new.target</code></li><li>在子类继承父类时，<code>new.target</code>指向初始化类的类定义，即子类</li></ul><h4 id="2-在ES5中如何限制函数通过new运算符调用"><a href="#2-在ES5中如何限制函数通过new运算符调用" class="headerlink" title="2. 在ES5中如何限制函数通过new运算符调用"></a>2. 在ES5中如何限制函数通过<code>new</code>运算符调用</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>this</code>将指向构造函数实例</p></li><li><p>普通调用函数，非严格模式<code>this</code>指向<code>window</code>，严格模式指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Window &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以通过判断<code>this</code>是否当前构造函数的实例，来判断是否通过<code>new</code>运算符调用，使用<code>this instanceof [构造函数]</code>，通过<code>new</code>调用返回<code>true</code>，普通调用返回<code>false</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 不建议使用 arguments.callee.name，在严格模式下arguments属性被移除</span></span><br><span class="line">  <span class="keyword">if</span>(!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Instance</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>()  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>但通过此方法判断并不完全准确，如果调用时通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向，将<code>this</code>指向构造函数实例，以上方法将无效</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()))  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-new-target"><a href="#3-new-target" class="headerlink" title="3. new.target"></a>3. new.target</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>new.target</code>指向构造方法或函数的引用</p></li><li><p>普通调用函数，<code>new.target</code>指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span>.<span class="property">target</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以使用<code>new.target</code>来限制构造函数必须通过<code>new</code>运算符调用</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变this指向</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>())) <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-使用new-target模拟实现抽象类"><a href="#4-使用new-target模拟实现抽象类" class="headerlink" title="4. 使用new.target模拟实现抽象类"></a>4. 使用<code>new.target</code>模拟实现抽象类</h4><ul><li><p>因为当子类继承父类时，<code>new.target</code>指向初始化类的类定义</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">P</span>() <span class="comment">// class P &#123; constructor() &#123; console.log(new.target) &#125; &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">S</span>() <span class="comment">// class S extends P &#123; constructor() &#123; super() &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>利用这一特性，可以模拟实现抽象类</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === P) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&#x27;Cannot create an instance of an abstract class.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">P</span>()) <span class="comment">// Uncaught SyntaxError: Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">S</span>()) <span class="comment">// S &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul><li>在ES5中，通过<code>new</code>运算符调用时<code>this</code>指向构造函数实例，普通调用时<code>this</code>在非严格模式指向<code>window</code>，严格模式指向<code>undefined</code>，利用这一特性，结合<code>this instanceof [构造函数]</code>，可以判断是否通过<code>new</code>运算符调用构造函数，但此方法并不安全，可以通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向</li><li>在ES6中，引入<code>new.target</code>属性，通过<code>new</code>运算符调用时<code>new.target</code>指向构造方法或函数的引用，普通调用函数，<code>new.target</code>指向<code>undefined</code>，可以通过此属性判断是否通过<code>new</code>运算符调用构造函数</li><li>利用<code>new.target</code>属性，可以模拟实现抽象类</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Preflight request</title>
      <link href="/blog//Preflight-request/"/>
      <url>/blog//Preflight-request/</url>
      
        <content type="html"><![CDATA[<h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><h4 id="1-什么是预检请求？"><a href="#1-什么是预检请求？" class="headerlink" title="1. 什么是预检请求？"></a>1. 什么是预检请求？</h4><blockquote><p>一个<code>CORS</code>预检请求是用于检查服务器是否支持<code>CORS</code>（跨域资源共享），由浏览器自动通过<code>OPTIONS</code>方法发起（<strong>非简单请求</strong>才会发起预检请求）。当预检请求完成，服务器确认允许后，才发起实际的HTTP请求。</p></blockquote><h4 id="2-简单请求与非简单请求"><a href="#2-简单请求与非简单请求" class="headerlink" title="2. 简单请求与非简单请求"></a>2. 简单请求与非简单请求</h4><ul><li><p>简单请求</p><ul><li>请求方法：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>请求首部字段只包含：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type<ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul></li></ul></li><li>如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器；也就是说，给定一个XMLHttpRequest实例xhr，没有调用xhr.upload.addEventListener()，以监听该上传请求</li><li>请求中没有使用ReadableStream对象</li></ul></li><li><p>非简单请求</p><ul><li>不满足简单请求的都是非简单请求</li></ul></li></ul><h4 id="3-预检请求中的请求首部字段"><a href="#3-预检请求中的请求首部字段" class="headerlink" title="3. 预检请求中的请求首部字段"></a>3. 预检请求中的请求首部字段</h4><ul><li>Origin：请求源URL（不包含路径）</li><li>Access-Control-Request-Method：实际请求所使用的HTTP方法</li><li>Access-Control-Request-Headers：实际请求时携带的自定义首部字段</li></ul><img src="/blog/Preflight-request/request-header.png" class="" title="Preflight request header"><h4 id="4-预见请求中的响应首部字段"><a href="#4-预见请求中的响应首部字段" class="headerlink" title="4. 预见请求中的响应首部字段"></a>4. 预见请求中的响应首部字段</h4><ul><li>Access-Control-Allow-Origin：允许该源访问资源地址，可以使用<code>*</code>通配符，表示任意源（仅当不需要携带<code>Cookie</code>时，如果携带<code>Cookie</code>，必须指定具体的源地址，否则将会请求失败）</li><li>Access-Control-Allow-Methods：允许使用的HTTP方法</li><li>Access-Control-Allow-Headers：允许使用的请求首部字段</li><li>Access-Control-Allow-Credentials：是否允许携带Cookie</li><li>Access-Control-Expose-Headers：<code>XMLHttpRequest</code>对象的 <code>getResponseHeader()</code>方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头</li><li>Access-Control-Max-Age：指定预检请求缓存时间，单位为秒，默认5秒</li></ul><img src="/blog/Preflight-request/response-header.png" class="" title="Preflight response header"><h4 id="5-完整请求流程图"><a href="#5-完整请求流程图" class="headerlink" title="5. 完整请求流程图"></a>5. 完整请求流程图</h4><img src="/blog/Preflight-request/request-flow.png" class="" title="request flow">]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
